# bot.py

import os
import logging
import threading
import time
import datetime
import json
import pytz
import requests
from telegram import Update, ParseMode
from telegram.ext import Updater, CommandHandler, CallbackContext, Job, ConversationHandler, MessageHandler, Filters
from telegram.error import Conflict
import html
from http.server import BaseHTTPRequestHandler, HTTPServer

class HealthHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-Type', 'text/plain')
        self.end_headers()
        self.wfile.write(b'OK')

    def do_HEAD(self):
        # Respond to health check HEAD requests
        self.send_response(200)
        self.end_headers()

def start_health_server():
    port = int(os.environ.get('PORT', 5000))
    server = HTTPServer(('0.0.0.0', port), HealthHandler)
    server.serve_forever()

# --- –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π ---
REMINDERS_FILE = "reminders.json"

logging.basicConfig(
    format="%(asctime)s ‚Äî %(levelname)s ‚Äî %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

def error_handler(update: Update, context: CallbackContext):
    """
    Handle errors by logging them without crashing the bot.
    """
    if isinstance(context.error, Conflict):
        return
    logger.error("Uncaught exception:", exc_info=context.error)

def subscribe_chat(chat_id):
    try:
        with open("subscribed_chats.json", "r") as f:
            data = f.read().strip()
            chats = json.loads(data) if data else []
    except (FileNotFoundError, json.JSONDecodeError):
        chats = []

    if chat_id not in chats:
        chats.append(chat_id)
        save_chats(chats)

def save_chats(chats):
    with open("subscribed_chats.json", "w") as f:
        json.dump(chats, f)

# –§—É–Ω–∫—Ü–∏—è ping –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∑–∞—Å—ã–ø–∞–Ω–∏—è –Ω–∞ Render
def ping_self(context: CallbackContext):
    """
    –ü–∏–Ω–≥—É–µ—Ç —Å–∞–º —Å–µ–±—è —á—Ç–æ–±—ã –Ω–µ –∑–∞—Å—ã–ø–∞—Ç—å –Ω–∞ Render free tier
    """
    try:
        base_url = os.environ.get('BASE_URL', 'https://telegram-repeat-bot.onrender.com')
        response = requests.get(base_url, timeout=10)
        logger.info(f"Self-ping successful: {response.status_code}")
    except Exception as e:
        logger.warning(f"Self-ping failed: {e}")

# --- /start –∏ /test –∫–æ–º–∞–Ω–¥—ã ---
def start(update: Update, context: CallbackContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start.
    """
    chat_id = update.effective_chat.id
    logger.info("Received /start from chat %s", chat_id)
    subscribe_chat(chat_id)
    context.bot.send_message(chat_id=chat_id,
                             text="‚úÖ <b>–ë–æ—Ç –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –≤ —ç—Ç–æ–º —á–∞—Ç–µ</b>",
                             parse_mode=ParseMode.HTML)

def test(update: Update, context: CallbackContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /test –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞.
    """
    chat_id = update.effective_chat.id
    logger.info("Received /test from chat %s", chat_id)
    subscribe_chat(chat_id)
    context.bot.send_message(chat_id=chat_id,
                             text="‚úÖ <b>–ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ!</b>",
                             parse_mode=ParseMode.HTML)

# --- –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è ConversationHandler —Å–æ—Å—Ç–æ—è–Ω–∏–π ---
REMINDER_DATE, REMINDER_TEXT = range(2)
DAILY_TIME, DAILY_TEXT = range(2)
WEEKLY_DAY, WEEKLY_TIME, WEEKLY_TEXT = range(3)
REM_DEL_ID = 0

# --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π (–≥–ª–æ–±–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫) ---
def load_reminders():
    """
    Load reminders from the JSON file, returning an empty list if the file is missing,
    empty, or contains invalid JSON.
    """
    try:
        with open(REMINDERS_FILE, "r", encoding='utf-8') as f:
            data = f.read().strip()
            if not data:
                return []
            return json.loads(data)
    except (FileNotFoundError, json.JSONDecodeError):
        return []

def save_reminders(reminders):
    with open(REMINDERS_FILE, "w", encoding='utf-8') as f:
        json.dump(reminders, f, ensure_ascii=False, indent=2)

def get_next_reminder_id():
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ª–µ–¥—É—é—â–∏–π ID –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
    """
    reminders = load_reminders()
    if not reminders:
        return "1"
    
    # –ù–∞–π—Ç–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π ID –∏ –¥–æ–±–∞–≤–∏—Ç—å 1
    max_id = 0
    for reminder in reminders:
        try:
            reminder_id = int(reminder.get("id", "0"))
            if reminder_id > max_id:
                max_id = reminder_id
        except ValueError:
            continue
    
    return str(max_id + 1)

# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ä–∞–∑–æ–≤–æ–≥–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è ---
def start_add_one_reminder(update: Update, context: CallbackContext):
    update.message.reply_text("üìÖ <b>–†–∞–∑–æ–≤–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ</b>\n\n–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î –ß–ß:–ú–ú\n–ù–∞–ø—Ä–∏–º–µ—Ä: 2024-07-10 16:30", parse_mode=ParseMode.HTML)
    return REMINDER_DATE

def receive_reminder_datetime(update: Update, context: CallbackContext):
    text = update.message.text.strip()
    try:
        dt = datetime.datetime.strptime(text, "%Y-%m-%d %H:%M")
        if dt < datetime.datetime.now():
            update.message.reply_text("‚ö†Ô∏è <b>–û—à–∏–±–∫–∞:</b> –î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è —É–∂–µ –ø—Ä–æ—à–ª–∏.\n–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è:", parse_mode=ParseMode.HTML)
            return REMINDER_DATE
        context.user_data["reminder_datetime"] = text
        update.message.reply_text("‚úèÔ∏è <b>–¢–µ–∫—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è</b>\n\n–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è HTML —Ç–µ–≥–∏ –∏ —Å—Å—ã–ª–∫–∏):", parse_mode=ParseMode.HTML)
        return REMINDER_TEXT
    except Exception:
        update.message.reply_text("‚ùå <b>–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç</b>\n\n–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î –ß–ß:–ú–ú:", parse_mode=ParseMode.HTML)
        return REMINDER_DATE

def receive_reminder_text(update: Update, context: CallbackContext):
    reminders = load_reminders()
    new_id = get_next_reminder_id()
    reminder_text = update.message.text_html if update.message.text_html else update.message.text.strip()
    
    reminders.append({
        "id": new_id,
        "type": "once",
        "datetime": context.user_data["reminder_datetime"],
        "text": reminder_text
    })
    save_reminders(reminders)
    
    # –ü–ª–∞–Ω–∏—Ä—É–µ–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ
    schedule_reminder(context.dispatcher.job_queue, reminders[-1])
    
    update.message.reply_text(
        f"‚úÖ <b>–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ #{new_id} –¥–æ–±–∞–≤–ª–µ–Ω–æ</b>\n\n"
        f"üìÖ <i>{context.user_data['reminder_datetime']}</i>\n"
        f"üí¨ {reminder_text}", 
        parse_mode=ParseMode.HTML
    )
    return ConversationHandler.END

# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–≥–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è ---
def start_add_daily_reminder(update: Update, context: CallbackContext):
    update.message.reply_text("üîÑ <b>–ï–∂–µ–¥–Ω–µ–≤–Ω–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ</b>\n\n–í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú\n–ù–∞–ø—Ä–∏–º–µ—Ä: 08:00", parse_mode=ParseMode.HTML)
    return DAILY_TIME

def receive_daily_time(update: Update, context: CallbackContext):
    text = update.message.text.strip()
    try:
        time.strptime(text, "%H:%M")
        context.user_data["daily_time"] = text
        update.message.reply_text("‚úèÔ∏è <b>–¢–µ–∫—Å—Ç –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–≥–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è</b>\n\n–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è HTML —Ç–µ–≥–∏ –∏ —Å—Å—ã–ª–∫–∏):", parse_mode=ParseMode.HTML)
        return DAILY_TEXT
    except Exception:
        update.message.reply_text("‚ùå <b>–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç</b>\n\n–í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú:", parse_mode=ParseMode.HTML)
        return DAILY_TIME

def receive_daily_text(update: Update, context: CallbackContext):
    reminders = load_reminders()
    new_id = get_next_reminder_id()
    reminder_text = update.message.text_html if update.message.text_html else update.message.text.strip()
    
    reminders.append({
        "id": new_id,
        "type": "daily",
        "time": context.user_data["daily_time"],
        "text": reminder_text
    })
    save_reminders(reminders)
    
    # –ü–ª–∞–Ω–∏—Ä—É–µ–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ
    schedule_reminder(context.dispatcher.job_queue, reminders[-1])
    
    update.message.reply_text(
        f"‚úÖ <b>–ï–∂–µ–¥–Ω–µ–≤–Ω–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ #{new_id} –¥–æ–±–∞–≤–ª–µ–Ω–æ</b>\n\n"
        f"üïê <i>–ö–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ {context.user_data['daily_time']}</i>\n"
        f"üí¨ {reminder_text}", 
        parse_mode=ParseMode.HTML
    )
    return ConversationHandler.END

# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ–≥–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è ---
def start_add_weekly_reminder(update: Update, context: CallbackContext):
    update.message.reply_text("üìÜ <b>–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ</b>\n\n–í–≤–µ–¥–∏—Ç–µ –¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏:\n–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫, –í—Ç–æ—Ä–Ω–∏–∫, –°—Ä–µ–¥–∞, –ß–µ—Ç–≤–µ—Ä–≥, –ü—è—Ç–Ω–∏—Ü–∞, –°—É–±–±–æ—Ç–∞, –í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ", parse_mode=ParseMode.HTML)
    return WEEKLY_DAY

def receive_weekly_day(update: Update, context: CallbackContext):
    text = update.message.text.strip().lower()
    days = ["–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫", "–≤—Ç–æ—Ä–Ω–∏–∫", "—Å—Ä–µ–¥–∞", "—á–µ—Ç–≤–µ—Ä–≥", "–ø—è—Ç–Ω–∏—Ü–∞", "—Å—É–±–±–æ—Ç–∞", "–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ"]
    if text not in days:
        update.message.reply_text("‚ùå <b>–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑:\n–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫, –í—Ç–æ—Ä–Ω–∏–∫, –°—Ä–µ–¥–∞, –ß–µ—Ç–≤–µ—Ä–≥, –ü—è—Ç–Ω–∏—Ü–∞, –°—É–±–±–æ—Ç–∞, –í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ", parse_mode=ParseMode.HTML)
        return WEEKLY_DAY
    context.user_data["weekly_day"] = text
    update.message.reply_text("üïê <b>–í—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è</b>\n\n–í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú:", parse_mode=ParseMode.HTML)
    return WEEKLY_TIME

def receive_weekly_time(update: Update, context: CallbackContext):
    text = update.message.text.strip()
    try:
        time.strptime(text, "%H:%M")
        context.user_data["weekly_time"] = text
        update.message.reply_text("‚úèÔ∏è <b>–¢–µ–∫—Å—Ç –µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ–≥–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è</b>\n\n–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è HTML —Ç–µ–≥–∏ –∏ —Å—Å—ã–ª–∫–∏):", parse_mode=ParseMode.HTML)
        return WEEKLY_TEXT
    except Exception:
        update.message.reply_text("‚ùå <b>–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç</b>\n\n–í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú:", parse_mode=ParseMode.HTML)
        return WEEKLY_TIME

def receive_weekly_text(update: Update, context: CallbackContext):
    reminders = load_reminders()
    new_id = get_next_reminder_id()
    reminder_text = update.message.text_html if update.message.text_html else update.message.text.strip()
    
    reminders.append({
        "id": new_id,
        "type": "weekly",
        "day": context.user_data["weekly_day"],
        "time": context.user_data["weekly_time"],
        "text": reminder_text
    })
    save_reminders(reminders)
    
    # –ü–ª–∞–Ω–∏—Ä—É–µ–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ
    schedule_reminder(context.dispatcher.job_queue, reminders[-1])
    
    update.message.reply_text(
        f"‚úÖ <b>–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ #{new_id} –¥–æ–±–∞–≤–ª–µ–Ω–æ</b>\n\n"
        f"üìÖ <i>–ö–∞–∂–¥—ã–π {context.user_data['weekly_day'].title()} –≤ {context.user_data['weekly_time']}</i>\n"
        f"üí¨ {reminder_text}", 
        parse_mode=ParseMode.HTML
    )
    return ConversationHandler.END

# --- –°–ø–∏—Å–æ–∫ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π ---
def list_reminders(update: Update, context: CallbackContext):
    reminders = load_reminders()
    if not reminders:
        update.message.reply_text("üì≠ <b>–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π</b>", parse_mode=ParseMode.HTML)
        return
    
    lines = ["üìã <b>–í–∞—à–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è:</b>\n"]
    
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ ID –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
    reminders.sort(key=lambda x: int(x.get("id", "0")))
    
    for i, r in enumerate(reminders, 1):
        if r["type"] == "once":
            lines.append(f"<b>#{i}</b> [üìÖ –†–∞–∑–æ–≤–æ] <i>{r['datetime']}</i>\nüí¨ {r['text']}\n")
        elif r["type"] == "daily":
            lines.append(f"<b>#{i}</b> [üîÑ –ï–∂–µ–¥–Ω–µ–≤–Ω–æ] <i>{r['time']}</i>\nüí¨ {r['text']}\n")
        elif r["type"] == "weekly":
            lines.append(f"<b>#{i}</b> [üìÜ –ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ] <i>{r['day'].title()} {r['time']}</i>\nüí¨ {r['text']}\n")
    
    message_text = "\n".join(lines)
    
    # Telegram –∏–º–µ–µ—Ç –ª–∏–º–∏—Ç –Ω–∞ –¥–ª–∏–Ω—É —Å–æ–æ–±—â–µ–Ω–∏—è
    if len(message_text) > 4000:
        # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —á–∞—Å—Ç–∏
        chunks = []
        current_chunk = "üìã <b>–í–∞—à–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è:</b>\n\n"
        
        for line in lines[1:]:  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
            if len(current_chunk + line) > 4000:
                chunks.append(current_chunk)
                current_chunk = line
            else:
                current_chunk += line
        
        if current_chunk:
            chunks.append(current_chunk)
        
        for chunk in chunks:
            update.message.reply_text(chunk, parse_mode=ParseMode.HTML)
    else:
        update.message.reply_text(message_text, parse_mode=ParseMode.HTML)

# --- –£–¥–∞–ª–µ–Ω–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è ---
def start_delete_reminder(update: Update, context: CallbackContext):
    reminders = load_reminders()
    if not reminders:
        update.message.reply_text("üì≠ <b>–£ –≤–∞—Å –Ω–µ—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è</b>", parse_mode=ParseMode.HTML)
        return ConversationHandler.END
    
    lines = ["üóë <b>–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:</b>\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä:\n"]
    
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ ID –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
    reminders.sort(key=lambda x: int(x.get("id", "0")))
    
    for i, r in enumerate(reminders, 1):
        if r["type"] == "once":
            lines.append(f"<b>{i}.</b> [üìÖ –†–∞–∑–æ–≤–æ] <i>{r['datetime']}</i>\nüí¨ {r['text'][:50]}{'...' if len(r['text']) > 50 else ''}")
        elif r["type"] == "daily":
            lines.append(f"<b>{i}.</b> [üîÑ –ï–∂–µ–¥–Ω–µ–≤–Ω–æ] <i>{r['time']}</i>\nüí¨ {r['text'][:50]}{'...' if len(r['text']) > 50 else ''}")
        elif r["type"] == "weekly":
            lines.append(f"<b>{i}.</b> [üìÜ –ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ] <i>{r['day'].title()} {r['time']}</i>\nüí¨ {r['text'][:50]}{'...' if len(r['text']) > 50 else ''}")
    
    update.message.reply_text("\n\n".join(lines), parse_mode=ParseMode.HTML)
    return REM_DEL_ID

def confirm_delete_reminder(update: Update, context: CallbackContext):
    try:
        reminder_number = int(update.message.text.strip())
        reminders = load_reminders()
        
        if reminder_number < 1 or reminder_number > len(reminders):
            update.message.reply_text("‚ùå <b>–ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä</b>\n\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –æ—Ç 1 –¥–æ " + str(len(reminders)), parse_mode=ParseMode.HTML)
            return REM_DEL_ID
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ ID –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
        reminders.sort(key=lambda x: int(x.get("id", "0")))
        reminder_to_delete = reminders[reminder_number - 1]
        
        # –£–¥–∞–ª—è–µ–º –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ
        all_reminders = load_reminders()
        new_list = [r for r in all_reminders if r["id"] != reminder_to_delete["id"]]
        save_reminders(new_list)
        
        update.message.reply_text(f"‚úÖ <b>–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ #{reminder_number} —É–¥–∞–ª–µ–Ω–æ</b>", parse_mode=ParseMode.HTML)
        
        # –ü–µ—Ä–µ–ø–ª–∞–Ω–∏—Ä—É–µ–º –≤—Å–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
        reschedule_all_reminders(context.dispatcher.job_queue)
        
    except ValueError:
        update.message.reply_text("‚ùå <b>–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è</b>", parse_mode=ParseMode.HTML)
        return REM_DEL_ID
    
    return ConversationHandler.END

# --- –û—á–∏—Å—Ç–∫–∞ –≤—Å–µ—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π ---
def clear_reminders(update: Update, context: CallbackContext):
    save_reminders([])
    
    # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ –∑–∞–¥–∞–Ω–∏—è
    job_queue = context.dispatcher.job_queue
    current_jobs = job_queue.jobs()
    for job in current_jobs:
        if hasattr(job.context, 'get') and isinstance(job.context, dict):
            job.schedule_removal()
    
    update.message.reply_text("üóë <b>–í—Å–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è —É–¥–∞–ª–µ–Ω—ã</b>", parse_mode=ParseMode.HTML)

# --- –°–ª–µ–¥—É—é—â–µ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ ---
def next_notification(update: Update, context: CallbackContext):
    reminders = load_reminders()
    if not reminders:
        update.message.reply_text("üì≠ <b>–ù–µ—Ç –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π</b>", parse_mode=ParseMode.HTML)
        return
    
    now = datetime.datetime.now()
    soonest = None
    soonest_time = None
    days = ["–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫", "–≤—Ç–æ—Ä–Ω–∏–∫", "—Å—Ä–µ–¥–∞", "—á–µ—Ç–≤–µ—Ä–≥", "–ø—è—Ç–Ω–∏—Ü–∞", "—Å—É–±–±–æ—Ç–∞", "–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ"]
    
    for r in reminders:
        t = None
        if r["type"] == "once":
            try:
                t = datetime.datetime.strptime(r["datetime"], "%Y-%m-%d %H:%M")
                if t < now:  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ—à–µ–¥—à–∏–µ —Ä–∞–∑–æ–≤—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
                    continue
            except ValueError:
                continue
        elif r["type"] == "daily":
            try:
                h, m = map(int, r["time"].split(":"))
                candidate = now.replace(hour=h, minute=m, second=0, microsecond=0)
                if candidate < now:
                    candidate += datetime.timedelta(days=1)
                t = candidate
            except ValueError:
                continue
        elif r["type"] == "weekly":
            try:
                weekday = days.index(r["day"])
                h, m = map(int, r["time"].split(":"))
                candidate = now.replace(hour=h, minute=m, second=0, microsecond=0)
                days_ahead = (weekday - now.weekday() + 7) % 7
                if days_ahead == 0 and candidate < now:
                    days_ahead = 7
                t = candidate + datetime.timedelta(days=days_ahead)
            except (ValueError, IndexError):
                continue
        
        if t and (soonest_time is None or t < soonest_time):
            soonest_time = t
            soonest = r
    
    if soonest is None:
        update.message.reply_text("üì≠ <b>–ù–µ—Ç –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π</b>", parse_mode=ParseMode.HTML)
        return
    
    time_diff = soonest_time - now
    if time_diff.days > 0:
        time_str = f"—á–µ—Ä–µ–∑ {time_diff.days} –¥–Ω."
    elif time_diff.seconds > 3600:
        hours = time_diff.seconds // 3600
        time_str = f"—á–µ—Ä–µ–∑ {hours} —á."
    elif time_diff.seconds > 60:
        minutes = time_diff.seconds // 60
        time_str = f"—á–µ—Ä–µ–∑ {minutes} –º–∏–Ω."
    else:
        time_str = "–º–µ–Ω–µ–µ —á–µ–º —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É"
    
    if soonest["type"] == "once":
        msg = f"üìÖ <b>–ë–ª–∏–∂–∞–π—à–µ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ</b>\n\n<i>–†–∞–∑–æ–≤–æ: {soonest['datetime']}</i>\n‚è∞ {time_str}\nüí¨ {soonest['text']}"
    elif soonest["type"] == "daily":
        msg = f"üîÑ <b>–ë–ª–∏–∂–∞–π—à–µ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ</b>\n\n<i>–ï–∂–µ–¥–Ω–µ–≤–Ω–æ: {soonest['time']}</i>\n‚è∞ {time_str}\nüí¨ {soonest['text']}"
    elif soonest["type"] == "weekly":
        msg = f"üìÜ <b>–ë–ª–∏–∂–∞–π—à–µ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ</b>\n\n<i>–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ: {soonest['day'].title()} {soonest['time']}</i>\n‚è∞ {time_str}\nüí¨ {soonest['text']}"
    
    update.message.reply_text(msg, parse_mode=ParseMode.HTML)

def cancel_reminder(update: Update, context: CallbackContext):
    """
    –û—Ç–º–µ–Ω–∞ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è.
    """
    update.message.reply_text("‚ùå <b>–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞</b>", parse_mode=ParseMode.HTML)
    return ConversationHandler.END

# --- Scheduling helpers ---
from datetime import datetime, time as dt_time, timedelta

def send_reminder(context: CallbackContext):
    """
    –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ç–µ–∫—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –≤—Å–µ–º –ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–º —á–∞—Ç–∞–º.
    """
    reminder = context.job.context
    try:
        with open("subscribed_chats.json", "r") as f:
            chats = json.load(f)
        
        reminder_text = f"üîî <b>–ù–ê–ü–û–ú–ò–ù–ê–ù–ò–ï</b>\n\n{reminder['text']}"
        
        for cid in chats:
            try:
                context.bot.send_message(chat_id=cid, text=reminder_text, parse_mode=ParseMode.HTML)
            except Exception as e:
                logger.error(f"Failed to send reminder to chat {cid}: {e}")
        
        # –£–¥–∞–ª—è–µ–º —Ä–∞–∑–æ–≤—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏
        if reminder["type"] == "once":
            reminders = load_reminders()
            reminders = [r for r in reminders if r["id"] != reminder["id"]]
            save_reminders(reminders)
            
    except Exception as e:
        logger.error(f"Error in send_reminder: {e}")

def schedule_reminder(job_queue, reminder):
    """
    –î–æ–±–∞–≤–ª—è–µ—Ç –∑–∞–¥–∞–Ω–∏–µ –≤ JobQueue –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è.
    """
    try:
        # –°–Ω–∞—á–∞–ª–∞ —É–¥–∞–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ –∑–∞–¥–∞–Ω–∏–µ —Å —Ç–∞–∫–∏–º –∂–µ ID, –µ—Å–ª–∏ –µ—Å—Ç—å
        current_jobs = job_queue.jobs()
        for job in current_jobs:
            if hasattr(job, 'name') and job.name == f"reminder_{reminder['id']}":
                job.schedule_removal()
        
        if reminder["type"] == "once":
            run_dt = datetime.strptime(reminder["datetime"], "%Y-%m-%d %H:%M")
            if run_dt > datetime.now():  # –ü–ª–∞–Ω–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –±—É–¥—É—â–∏–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
                job_queue.run_once(send_reminder, run_dt, context=reminder, name=f"reminder_{reminder['id']}")
        elif reminder["type"] == "daily":
            h, m = map(int, reminder["time"].split(":"))
            job_queue.run_daily(send_reminder, dt_time(hour=h, minute=m), context=reminder, name=f"reminder_{reminder['id']}")
        elif reminder["type"] == "weekly":
            days_map = {
                "–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫": 0, "–≤—Ç–æ—Ä–Ω–∏–∫": 1, "—Å—Ä–µ–¥–∞": 2,
                "—á–µ—Ç–≤–µ—Ä–≥": 3, "–ø—è—Ç–Ω–∏—Ü–∞": 4, "—Å—É–±–±–æ—Ç–∞": 5, "–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ": 6
            }
            weekday = days_map[reminder["day"].lower()]
            h, m = map(int, reminder["time"].split(":"))
            job_queue.run_daily(
                send_reminder,
                dt_time(hour=h, minute=m),
                context=reminder,
                days=(weekday,),
                name=f"reminder_{reminder['id']}"
            )
    except Exception as e:
        logger.error(f"Error scheduling reminder {reminder.get('id', 'unknown')}: {e}")

def schedule_all_reminders(job_queue):
    """
    –ó–∞–≥—Ä—É–∂–∞–µ—Ç –≤—Å–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∏ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤—ã–≤–∞–µ—Ç –∏—Ö.
    """
    reminders = load_reminders()
    for reminder in reminders:
        schedule_reminder(job_queue, reminder)

def reschedule_all_reminders(job_queue):
    """
    –ü–µ—Ä–µ–ø–ª–∞–Ω–∏—Ä—É–µ—Ç –≤—Å–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è)
    """
    # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ —Ç–µ–∫—É—â–∏–µ –∑–∞–¥–∞–Ω–∏—è
    current_jobs = job_queue.jobs()
    for job in current_jobs:
        if hasattr(job, 'name') and job.name and job.name.startswith('reminder_'):
            job.schedule_removal()
    
    # –ü–ª–∞–Ω–∏—Ä—É–µ–º –∑–∞–Ω–æ–≤–æ
    schedule_all_reminders(job_queue)

def main():
    token = os.environ['BOT_TOKEN']
    port = int(os.environ.get('PORT', 8000))
    updater = Updater(token=token, use_context=True)
    
    # Reset any existing webhook so polling can start cleanly
    try:
        res = updater.bot.delete_webhook(drop_pending_updates=True)
        logger.info("Webhook deleted: %s", res)
    except Exception as e:
        logger.error("Error deleting webhook: %s", e)
    
    dp = updater.dispatcher
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥ –ü–ï–†–í–´–ú–ò
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("test", test))
    
    conv = ConversationHandler(
        entry_points=[CommandHandler("remind", start_add_one_reminder)],
        states={
            REMINDER_DATE: [MessageHandler(Filters.text & ~Filters.command, receive_reminder_datetime)],
            REMINDER_TEXT: [MessageHandler(Filters.text & ~Filters.command, receive_reminder_text)],
        },
        fallbacks=[CommandHandler("cancel", cancel_reminder)],
        allow_reentry=True,
    )
    dp.add_handler(conv)
    
    conv_daily = ConversationHandler(
        entry_points=[CommandHandler("remind_daily", start_add_daily_reminder)],
        states={
            DAILY_TIME: [MessageHandler(Filters.text & ~Filters.command, receive_daily_time)],
            DAILY_TEXT: [MessageHandler(Filters.text & ~Filters.command, receive_daily_text)],
        },
        fallbacks=[CommandHandler("cancel", cancel_reminder)],
        allow_reentry=True,
    )
    dp.add_handler(conv_daily)

    conv_weekly = ConversationHandler(
        entry_points=[CommandHandler("remind_weekly", start_add_weekly_reminder)],
        states={
            WEEKLY_DAY: [MessageHandler(Filters.text & ~Filters.command, receive_weekly_day)],
            WEEKLY_TIME: [MessageHandler(Filters.text & ~Filters.command, receive_weekly_time)],
            WEEKLY_TEXT: [MessageHandler(Filters.text & ~Filters.command, receive_weekly_text)],
        },
        fallbacks=[CommandHandler("cancel", cancel_reminder)],
        allow_reentry=True,
    )
    dp.add_handler(conv_weekly)
    
    dp.add_handler(CommandHandler("list_reminders", list_reminders))
    
    conv_del = ConversationHandler(
        entry_points=[CommandHandler("del_reminder", start_delete_reminder)],
        states={REM_DEL_ID: [MessageHandler(Filters.text & ~Filters.command, confirm_delete_reminder)]},
        fallbacks=[CommandHandler("cancel", cancel_reminder)],
        allow_reentry=True,
    )
    dp.add_handler(conv_del)
    
    dp.add_handler(CommandHandler("clear_reminders", clear_reminders))
    dp.add_handler(CommandHandler("next", next_notification))

    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
    dp.add_error_handler(error_handler)

    # –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
    schedule_all_reminders(updater.job_queue)
    
    # –î–æ–±–∞–≤–ª—è–µ–º ping –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∑–∞—Å—ã–ø–∞–Ω–∏—è –Ω–∞ Render
    updater.job_queue.run_repeating(ping_self, interval=600, first=60)

    # Health check server for Render free tier
    threading.Thread(target=start_health_server, daemon=True).start()
    
    # Always run in polling mode
    updater.bot.delete_webhook(drop_pending_updates=True)
    updater.start_polling(drop_pending_updates=True)
    logger.info("Polling mode started, bot is ready")
    updater.idle()

if __name__ == "__main__":
    main()

